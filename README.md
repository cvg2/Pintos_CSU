# Pintos_CSU
This repository contains implementations of several assignments implemented in Pintos educational operating system.
TASK 1: Efficient Alarm Clock - Timer.c
In this task we were supposed to edit the function timer_sleep() so internally did not have to be on “busy waiting”. We add the attribute wake_up_time to the structure thread . We reimplement the function by creating a sleep list of threads where we will store the threads that have to wait. We need to calculate when the thread needs to wake up. We did that by using the timer_ticks() that give us the total number of ticks and the ticks that the thread need to wait. We add them together to know when the thread will wake up again. Because we are going to access the critical region, we disable the interruptions  and then we insert the thread that has to sleep in the sleep list and we change the status of thread to THRD_SLEEP and we enable the interruptions again.  We use the function list_insert_ordered that uses the bool function sort_wake_up_time to sort by the wake up time of the threads. We also initialize sleep list in the function timer_init.
To check when a thread must wake up, we use the function timer_interrupt(). We know that the sleep list is ordered by increasing wake up time, we go through the list and unblock all the thread that have lower ticks than the timer_ticks(). The wake-up process for a thread will go from removing this thread from the sleep list and adding it to the ready list and change its status to THRD_READY. The fact that we are not allowed to add functions except for the sort function made us modify the function thread_block to change the thread’s state to blocked or asleep. 



TASK 2: Basic Priority Scheduling - Thread.c Synch.c

In this task we need to give the thread the priority attribute. Each thread has a priority value so from now on we need to modify how the system work so the synchronization use the priorities. To do that we need to change some functions. We need to sort the ready list by the priorities, we do that by changing everywhere where a thread is inserted, we made the insertion ordered. We use list_insert_ordered that uses the bool function sort_priority. Every time a thread is created, we need to check if the new thread has higher priority than the current thread. If that happens we need to block the current thread and run the new thread. We do this by using thread_yield that insert the current thread in the ready list and change its status to THRD_READY and call the function schedule() which will choose the next thread to be run that is the one with the max priority from the ready list.
When a thread is unblocked because it was either sleep or blocked, we will add it to the ready list in a order way by using its priority and change its status to THRD_READY. 
In the function thread_yield() we just insert the current thread in the ready list in a order way by using its priority and change its status to THRD_READY.
In this task, we were also ask to implement the functions thread_set_priority() and thread_get_priority(). For thread_get_priority() we just passed the thread parameter and return its priority. For thread_set_priority() once we assign the new priority to the current thread we need to check if there is a thread with a higher priority in the ready list. So we compare the priority of the current thread with the first thread of the ready list( because we know that the first thread is the one with the highest priority of the list because that is how we insert the threads). If the first thread from the ready list has a higher priority, we will call thready_yield() to swap the execution of the threads.
We also change the synch.c file. In the function sema_down(), when a thread is blocked in a semaphore, it needs to insert the thread in the list of the waiters of this semaphore. Each semaphore has a list of waiters. We insert the current thread in the sema waiters list in an order way by using its priority and change its status to THRD_BLOCKED.
In the function sema_up(), when a semaphore “turns the light on green” we need to extract the first thread(the first thread is the thread that has the highest priority in the sema_waiters list because the list is ordered in a decreasing way). Insert the thread in the ready list and change its status to THRD_READY. Then it compares if the priority of this thread is higher than the current thread running. If the current thread has  a lower priority than the one that is just unblocked, it calls to thread_yield() to swap the execution of the threads.
In order to test the program we had to use printf to know what was going on between the lines of code. When we started to run all the cases we have 5/10 cases that passed. We had to run the programs by separately because we needed it so see and comprehend what was the program doing in each case.
